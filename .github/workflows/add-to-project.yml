---
# This workflow automatically adds new issues to the Ignite GitHub Project
# and applies relevant labels based on issue content.
#
# Required configuration:
# - Variables:
#   - PROJECT_URL: The URL of the GitHub project to add issues to
# - Secrets:
#   - ADD_TO_PROJECT_PAT: Personal Access Token with project and repo permissions
#
# The workflow triggers on issue opened events and includes:
# 1. add-to-project job: Adds the issue to the specified GitHub project
# 2. label_issues job: Automatically applies labels based on issue content

name: Add Issue to Project and Apply Labels

on:
  issues:
    types:
      - opened

jobs:
  add-to-project:
    name: Add issue to project
    runs-on: ubuntu-latest
    steps:
      - name: Add issue to project
        uses: actions/add-to-project@v0.5.0
        with:
          project-url: ${{ vars.PROJECT_URL }}
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}

  label_issues:
    name: Apply labels to issue
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Apply labels
        uses: actions/github-script@v7
        with:
          script: |
            const labels = [];

            // Apply default labels for Ignite lab issues
            labels.push('ignite-2025');
            labels.push('lab-546');

            // Add labels based on issue title or content
            const title = context.payload.issue.title.toLowerCase();
            const body = context.payload.issue.body?.toLowerCase() || '';

            // Security-related keywords
            if (title.includes('security') || body.includes('security') ||
                title.includes('zero trust') ||
                body.includes('zero trust')) {
              labels.push('security');
            }

            // Infrastructure-related keywords
            if (title.includes('infrastructure') ||
                body.includes('infrastructure') ||
                title.includes('network') || body.includes('network')) {
              labels.push('infrastructure');
            }

            // Data-related keywords
            if (title.includes('data') || body.includes('data')) {
              labels.push('data');
            }

            // SOC-related keywords
            if (title.includes('soc') || body.includes('soc') ||
                title.includes('monitoring') ||
                body.includes('monitoring')) {
              labels.push('soc');
            }

            // Bug/Enhancement classification
            if (title.includes('bug') || title.includes('error') ||
                title.includes('issue')) {
              labels.push('bug');
            } else if (title.includes('feature') ||
                       title.includes('enhancement') ||
                       title.includes('improve')) {
              labels.push('enhancement');
            }

            // Apply all collected labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                labels: labels
              });
            }
